"""
Test file for simplifying a gpx file using gpx.simplify 
"""
import os
import utm
import requests
import sys
import gpxpy
import gpxpy.gpx
import gpxpy.geo as mod_geo
import json
import pprint
import copy
import logging
# pip install this 
from shapely.geometry import Point, MultiPoint
from shapely.ops import nearest_points
# import xml.etree.ElementTree as ET


 # pk.eyJ1IjoianVuZWJ1Z2d5IiwiYSI6ImNrY2YyMnE1eDBidmkyemsyOWZjbzU0Z24ifQ.mCT9XQLM_LyYO25qTN7xUQ 
def callMapBox(coords : list):
    """
    Takes a gpx file, opens it, simplifies, gets coords, calls mapbox, 
    outputs route generated by mapbox 
    """

    print("COORDS ARE ")

    print(coords)

    coordstring = ""
    for item in coords: 
        coordstring += f"{item[0]},{item[1]}"
        if item is not coords[-1]:
            coordstring += ";"
    print(coordstring)

        #73.99090404350912%2C40.727064885724246%3B-73.98744586616424%2C40.733505271200954
    # TODO: access_token needs to be abstracted out to a config file
    # Config.py should handle reading from config file 
    payload = {"geometries" : "geojson","steps": "true",
                "access_token" : "pk.eyJ1IjoianVuZWJ1Z2d5IiwiYSI6ImNrY2YyMnE1eDBidmkyemsyOWZjbzU0Z24ifQ.mCT9XQLM_LyYO25qTN7xUQ",
                "overview" : 'full' }
    
    # &geometries=geojson&steps=true&access_token=YOUR_MAPBOX_ACCESS_TOKEN
    
    r = requests.get(f"https://api.mapbox.com/directions/v5/mapbox/cycling/{coordstring}", params=payload)
    # print(r.url)
    # print(r.text)
  
    return json.loads(r.text)

    #  https://api.mapbox.com/directions/v5/cycling/{coordinates} 


def giveCueSheet(mygpx=None):
    """
    Returns a cuesheet JSON object -- a list of turn instructions provided by the mapbox Navigation API 
    Cuesheet Object is of format: 
    {cuesheet:
        [{
            "number" : INSTRUCTION NUMBER, 
            "Manuver" : TURN INSTRUCTION,                                 
            "coordinate" : [LON, LAT],
            'distance' : DISTANCE (meters?) 
        }]
    """

    # TODO need to change it so that we get the file from the website
    if mygpx is None:
        gpx_file = open(sys.argv[1], 'r')
        mygpx = gpxpy.parse(gpx_file)
    
    print(f"{len(mygpx.tracks[0].segments[0].points) } Before Simplification!")
    mygpx_simplified = copy.deepcopy(mygpx)
    mygpx_simplified.simplify(100) # 100M TOLERANCE 

    print(f"{len(mygpx.tracks[0].segments[0].points) } after simplification!")
    # coordlists = []    
    
    #break the track into 25 point pieces
    #each 25 coord list is stored in coordlists
    # https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks

    # [(lon, lat)] of original -- THIS ORIGNAL ROUTE FROM USER WITH ALL POINTS
    allpoints = [(pt.longitude, pt.latitude) for pt in mygpx.tracks[0].segments[0].points]

    # [(lon, lat )] of simplified - THIS IS SIMPLIFIED(100) FOR FIRST MAPBOX CALL
    points_simplified = [(pt.longitude, pt.latitude) for pt in mygpx_simplified.tracks[0].segments[0].points]

    # [[(lon, lat) * 25]] broken up into 25 coord lists for API call 
    coordlists = [points_simplified[i:i + 25] for i in range(0, len(points_simplified), 25)]
    # print(f"There were {i} many points in the gpx file after simplification")
    print(f"Coords were split into {len(coordlists)} API calls ")
    # output = open("out.gpx", "w")
    # outmb = open("out.geojson", "w")
    jsonlist = []
    cuesheet = {'cuesheet' : []}
    
    num_turn = 0
    for routesegment in coordlists: 
        linegeom = []
        j = callMapBox(routesegment)

        # get the line geometry returned by mapbox for the segment of the route we passed in 
        mbcoords = j["routes"][0]["geometry"]['coordinates']
        for item in mbcoords:
            linegeom.append(item)
        
        print(f"{len(routesegment)} ORIGINAL POINTS, {len(linegeom)}LINESTRING POINTS")
        
        #index of routesegment start and end point in original 
        
        start = mygpx.tracks[0].segments[0].points.index(routesegment[0])
        end = mygpx.tracks[0].segments[0].points.index(routesegment[-1])

        #TODO: shapely nearest_points to get start and end point
            '''
            # lon, lat
            Build list of shapely points of my mygpx.tracks[0].segments[0].points

            #this list is red points 
            shapelypoints = []s
            FOR tuple in mygpx.tracks[0].segment[0].points:
                shapelypoints.append(shapely.Point(tuple[0],tuple[1]))
        
            mltpt = MultiPoint(shapelypoints)

            # GREEN POINTS 
            simplified_start Pont(lon,lat) from routesegment[0]
            simplified_end Pont(lon,lat) from routesegment[-1]

            shapely.ops.nearest_point will find closest red point to the green point


            shapelypoints = [Point(lon,lat) for lon, lat in mygpx.tracks[0].segments[0].points ]
            
            shapely.ops.nearest_point on shapelypoints with start and end to get the start and end of the 
            segment that we are dealing with in the original route 
            '''

        # build gpx of this segment to simplify it down to the number of points in the route

        pts = [gpxpy.gpx.GPXTrackPoint(pt[0], pt[1]) for pt in allpoints[start:end]]
        seg_gpx = gpxpy.gpx.GPX()
        gpx_track = gpxpy.gpx.GPXTrack()
        gpx_segment = gpxpy.gpx.GPXTrackSegment()
        for pt in pts: 
            gpx_segment.points.append(pt)
        gpx_track.segments.append(gpx_segment)
        seg_gpx.tracks.append(gpx_track)
    
        seg_gpx_simplified = copy.deepcopy(mygpx)
        logging.debug(f"SIMPLIFYING SEGMENT BETWEEN {start} AND {end}")
        logging.debug(f"ORIGNALLY {len(pts)}")
        logging.debug("-" * 80)


        while len(seg_gpx_simplified.tracks[0].segments[0].points) > len(linegeom):
            seg_gpx_simplified = seg_gpx_simplified.simplify(0.1)
            print(f"{len(seg_gpx_simplified.tracks[0].segments[0].points)} > {len(linegeom)}")


        # simplify original downto ~= number of coords as line geom


        for leg in j["routes"][0]["legs"]:
            for step in leg['steps']:

                if step["maneuver"]["type"] == "turn":
                    cuesheet['cuesheet'].append({"number" : num_turn, "maneuver" : step["maneuver"]["instruction"], 
                                    "coordinate" :step["maneuver"]["location"], 'distance' : step["distance"]})
                    num_turn+=1
    #get dict of location and directions for each 25 pt segment

    # pprint.pprint(cuesheet)
    return cuesheet

    # {"cuesheet" : [{number : 0, manuver : "instruction goes here", "coordinate": [lat,long]}]}
def main():
    gpx_file = open(sys.argv[1], 'r')
    mygpx = gpxpy.parse(gpx_file)
    pprint.pprint(giveCueSheet(mygpx))

    #merge the jsons generated by the API -- dont need to do this anymore 
    # merged = {}
    # for j in jsonlist:
    #     merged.update(j)

    # create json with only location and instruction 

    # print(merged)
    # json.dump(j,outmb)
    # outmb.close()
    # output.close()



if __name__ == "__main__":
    main()





# Considerations: 
#     user gives gpx
#     server reads and simplifies gpx based on number of points
#     one mapbox call == 25 points

#     do untill processed all points
#         in increments of 25 points 
#             call mapbox api with coordinates
#             reciveve mabox coordinates and que sheet
#             compare differences between user and mapbox coordinates
#             if n coordinates differ by x amount 
#                 run api again on an unsimplified version of that segment
#                 do untill no diff for that segment
            
#             if no major differences between user gpx and mapbox coords,
#                 add instructions to que sheet
    
#     present que sheet to user 