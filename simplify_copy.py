"""
Test file for simplifying a gpx file using gpx.simplify 
"""
import os
import utm
import requests
import sys
import gpxpy
import gpxpy.gpx
import gpxpy.geo as mod_geo
import json
import pprint
import copy
import logging
import utm
#MATPLOTLIB TESTING ----------------------------------------
import matplotlib.pyplot as plt
# https://shapely.readthedocs.io/en/latest/code/linestring.py
# pip install this 
from descartes import PolygonPatch
from figures import SIZE, BLUE, GRAY, set_limits, plot_line
from figures import plot_coords as _plot_coords
import shapely.geometry
import shapely.ops
import geojson
# --------------------------------------------------
# import xml.etree.ElementTree as ET
DOPLOT = False

 # pk.eyJ1IjoianVuZWJ1Z2d5IiwiYSI6ImNrY2YyMnE1eDBidmkyemsyOWZjbzU0Z24ifQ.mCT9XQLM_LyYO25qTN7xUQ 
def callMapBox(coords : list):
    """
    Takes a gpx file, opens it, simplifies, gets coords, calls mapbox, 
    outputs route generated by mapbox 
    """

    print("COORDS ARE ")

    # print(coords)

    coordstring = ""
    for item in coords: 
        coordstring += f"{item[0]},{item[1]}"
        if item is not coords[-1]:
            coordstring += ";"
    # print(coordstring)

        #73.99090404350912%2C40.727064885724246%3B-73.98744586616424%2C40.733505271200954
    # TODO: access_token needs to be abstracted out to a config file
    # Config.py should handle reading from config file 
    payload = {"geometries" : "geojson","steps": "true",
                "access_token" : "pk.eyJ1IjoianVuZWJ1Z2d5IiwiYSI6ImNrY2YyMnE1eDBidmkyemsyOWZjbzU0Z24ifQ.mCT9XQLM_LyYO25qTN7xUQ",
                "overview" : 'full' }
    
    # &geometries=geojson&steps=true&access_token=YOUR_MAPBOX_ACCESS_TOKEN
    
    r = requests.get(f"https://api.mapbox.com/directions/v5/mapbox/cycling/{coordstring}", params=payload)
    # print(r.url)
    # print(r.text)
  
    return json.loads(r.text)

    #  https://api.mapbox.com/directions/v5/cycling/{coordinates} 

def slice_new_gpx(start : int, end : int, gpx : "GPX", simp  : int) -> "GPX":
    """
    create a new gpx object sliced from an other one 
    optional simplification 
    """
    seg_gpx = gpxpy.gpx.GPX()
    gpx_track = gpxpy.gpx.GPXTrack()
    gpx_segment = gpxpy.gpx.GPXTrackSegment()
    pts = mygpx.tracks[0].segments[0].points[start:end]
    for p in pts: 
        gpx_segment.points.append(p)

    gpx_track.segments.append(gpx_segment)
    seg_gpx.tracks.append(gpx_track)

    if simp != 0:
        seg_gpx.simplify(simp)

    return seg_gpx


def diffCheck(a : "List[tuples]", b: "List[tuples]", dist: int):
    """
    returns list or list of lists or none if no differences 
    dist is buffer distance
    """

    #shapely linestring of original route in UTM 
    a_shapely = shapely.geometry.LineString([(item[0],item[1]) for item in a])

    #shapely linestring of mapbox route in UTM 
    b_shapely = shapely.geometry.LineString([(item[0],item[1]) for item in b])

    #buffer to take difference with original route 
    b_shapely_buff = b_shapely.buffer(dist)
    # print(route_shapely.difference(mapbox_shapely))
    difference_lines = []
    
    #Linestring OR MultiLineString -- segments of original route that mapbox got wrong the first time
    difference_shapely = a_shapely.difference(b_shapely_buff)

    return difference_shapely,a_shapely, b_shapely, b_shapely_buff

def gpx_to_coordlist(gpx: "GPX",t="latlon") -> list:
    """
    Make a list of coordinates 
    mapbox : splits it into a list of 25 long 
    """
    newl = []
    if t == "latlon":
        newl = [(pt.longitude, pt.latitude) for pt in gpx.tracks[0].segments[0].points]

    elif t == "utm":
        for pt in gpx.tracks[0].segments[0].points:
            lat = pt[1]
            lon = pt[0]
            newl.append(utm.from_latlon(lat,lon))

    elif t == "mapbox":
        l = [(pt.longitude, pt.latitude) for pt in gpx.tracks[0].segments[0].points]
        newl = [l[i:i + 25] for i in range(0, len(l), 25)]
        print(f"Mapbox Split Into {len(newl)} lists")

    return newl
def giveCueSheet(mygpx=None):
    """
    Returns a cuesheet JSON object -- a list of turn instructions provided by the mapbox Navigation API 
    Cuesheet Object is of format: 
    {cuesheet:
        [{
            "number" : INSTRUCTION NUMBER, 
            "Manuver" : TURN INSTRUCTION,                                 
            "coordinate" : [LON, LAT],
            'distance' : DISTANCE (meters?) 
        }]
    """

    # TODO need to change it so that we get the file from the website
    if mygpx is None:
        gpx_file = open(sys.argv[1], 'r')
        mygpx = gpxpy.parse(gpx_file)
    
    print(f"{len(mygpx.tracks[0].segments[0].points) } Before Simplification!")
    mygpx_simplified = copy.deepcopy(mygpx)
    mygpx_simplified.simplify(10) # 100M TOLERANCE 

    print(f"{len(mygpx_simplified.tracks[0].segments[0].points) } after simplification!")
    # coordlists = []    
    
    #break the track into 25 point pieces
    #each 25 coord list is stored in coordlists
    # https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks

    # [(lon, lat)] of original -- THIS ORIGNAL ROUTE FROM USER WITH ALL POINTS
    allpoints = [(pt.longitude, pt.latitude) for pt in mygpx.tracks[0].segments[0].points]
    allutm = []
    for pt in allpoints:
        lat = pt[1]
        lon = pt[0]
        allutm.append(utm.from_latlon(lat,lon))
        
    # [(lon, lat )] of simplified - THIS IS SIMPLIFIED(100) FOR FIRST MAPBOX CALL
    points_simplified = [(pt.longitude, pt.latitude) for pt in mygpx_simplified.tracks[0].segments[0].points]

    # [[(lon, lat) * 25]] broken up into 25 coord lists for API call 
    coordlists = [points_simplified[i:i + 25] for i in range(0, len(points_simplified), 25)]
    # print(f"There were {i} many points in the gpx file after simplification")
    print(f"Coords were split into {len(coordlists)} API calls ")
    # output = open("out.gpx", "w")ex
    # outmb = open("out.geojson", "w")
    jsonlist = []
    cuesheet = {'cuesheet' : []}
    
    buffer_distance = 50
    
    num_turn = 0
    linegeom = {}
    lineutm = []
    for routesegment in coordlists: 
        
        j = callMapBox(routesegment)
        pprint.pprint(j)
        
        for leg in j["routes"][0]["legs"]:
            for step in leg['steps']:

                if step["maneuver"]["type"] == "turn":
                    cuesheet['cuesheet'].append({"number" : num_turn, "maneuver" : step["maneuver"]["instruction"], 
                                    "coordinate" :step["maneuver"]["location"], 'distance' : step["distance"]})
                    num_turn+=1

        # get the line geometry returned by mapbox for the segment of the route we passed in 
        mbcoords = j["routes"][0]["geometry"]['coordinates']
        for item in mbcoords:
            linegeom[turn_num].append(item)
            lineutm.append(utm.from_latlon(item[1],item[0]))
        



    # turnlocs = shapely.geometry.MultiPoint([cue['coordinate'] for cue in cuesheet['cuesheet']])
    difference_shapely, route_shapely ,mapbox_shapely, mapbox_shapely_buff = diffCheck(allutm,lineutm,buffer_distance)
    #get the coords of the parts we need to redo, might be or more lines 
    # fc = {"type": "FeatureCollection", "features": []}
    print(type(difference_shapely))
    if DOPLOT:
        fig, ax = plt.subplots()
        xl = []
        yl = []
        if isinstance(difference_shapely, shapely.geometry.linestring.LineString):
            xl,yl = difference_shapely.xy
            print(xl,yl)
            ax.plot(xl,yl, color='red')

        elif isinstance(difference_shapely, shapely.geometry.multilinestring.MultiLineString):
            for item in difference_shapely:
                _plot_coords(ax, item, zorder=1,color='red')
            #     x,y = item.xy
            #     xl.append(x)
            #     yl.append(y)
            # print(xl,yl)

        else:
            print("U WOT??")

        # now need to check if any of the difference coords are inside 
        patch1 = PolygonPatch(mapbox_shapely_buff, fc=BLUE, ec=BLUE, alpha=0.5, zorder=2)
        
        ax.add_patch(patch1)
        x,y = route_shapely.xy
        ax.plot(x,y,color='black')
        x,y = mapbox_shapely.xy
        ax.plot(x,y,color='yellow')
        
        ax.plot(xl,yl, color='red')
        # for pt in turnlocs:
        #     print(pt)
        #     ax.plot(pt.x,pt.y, color='green',markers='.')

        plt.show()

    # diff_in_latlong = []
    # # Need to go back to lat long to call mapbox on difference segements 
    # if isinstance(difference_shapely, shapely.geometry.linestring.LineString):
    #     #get list of eastings and northings
    #     eastings,northings = difference_shapely.xy
    #     for i in range(len(eastings)):
    #         # get zone for a given easting and northing?
    #         diff_in_latlong.append(utm.to_latlon(eastings[i], northings[i], allutm[0][2],allutm[0][3]))

    # elif isinstance(difference_shapely, shapely.geometry.multilinestring.MultiLineString):
    #     for line in difference_shapely:
    #         print(f"LINE: {line}")
    #         print("-" * 20)
    #         l = []
    #         eastings,northings = line.xy
    #         for i in range(len(eastings)):
    #             l.append(utm.to_latlon(eastings[i], northings[i], allutm[0][2],allutm[0][3]))
            
    #         diff_in_latlong.append(l)

    #                 # diff_in_latlong.append(utm.to_latlon(x,y))
    #     #     x,y = item.xy
    #     #     xl.append(x)
    #     #     yl.append(y)
    #     # print(xl,yl)
    # else:
    #     print("U WOT??")

    # print(diff_in_latlong)
    # points = mygpx.tracks[0].segments[0].points
    # start = 0
    # end = 0
    # if isinstance(diff_in_latlong[0], tuple):
    #     # this is a single list
    #     start = points.index(diff_in_latlong[0])
    #     end = points.index(diff_in_latlong[-1])
        

    #     seg_gpx = slice_new_gpx(start,end,mygpx,simp=20)
        
    #     to_mapbox = gpx_to_coordlist(seg,t="mapbox")
    #     for_difference = gpx_to_coordlist(seg,t="utm")

    #     for l in to_mapbox: 
    #         callMapBox(l)
        
        #create utm line 
        # call difference
        # if no difference continue 


 # pts = [gpxpy.gpx.GPXTrackPoint(pt[0], pt[1]) for pt in allpoints[start:end]]
        # seg_gpx = gpxpy.gpx.GPX()
        # gpx_track = gpxpy.gpx.GPXTrack()
        # gpx_segment = gpxpy.gpx.GPXTrackSegment()
        # for pt in pts: 
        #     gpx_segment.points.append(pt)
        # gpx_track.segments.append(gpx_segment)
        # seg_gpx.tracks.append(gpx_track)

    # elif isinstance(diff_in_latlong[0], list):
    
    # for segments in diff_segments
        # isolate wrong segment in orgiginal gpx

        # simpliy to ratio based on how long the segment is 
        # call to mapbox again 

        #diff check - if good, add turns to list of turns
        # else simplifiy again with smaller tolerance

        # recaclulate from where we got wrong 
        #splice back in by the surrounding points of the incorrect segment 


    # simplify 

    # # pprint.pprint(fc)
    # with open("difftest.geojson", "w") as d:
    #     d.write(str(fc))


        # print(f"{len(routesegment)} ORIGINAL POINTS, {len(linegeom)}LINESTRING POINTS")
        
        # #index of routesegment start and end point in original 
        
        # # simplify original downto ~= number of coords as line geom


    #get dict of location and directions for each 25 pt segment

    # pprint.pprint(cuesheet)
    return cuesheet

    # {"cuesheet" : [{number : 0, manuver : "instruction goes here", "coordinate": [lat,long]}]}
def main():
    gpx_file = open(sys.argv[1], 'r')
    mygpx = gpxpy.parse(gpx_file)
    giveCueSheet(mygpx)

    #merge the jsons generated by the API -- dont need to do this anymore 
    # merged = {}
    # for j in jsonlist:
    #     merged.update(j)

    # create json with only location and instruction 

    # print(merged)
    # json.dump(j,outmb)
    # outmb.close()
    # output.close()



if __name__ == "__main__":
    main()





# Considerations: 
#     user gives gpx
#     server reads and simplifies gpx based on number of points
#     one mapbox call == 25 points

#     do untill processed all points
#         in increments of 25 points 
#             call mapbox api with coordinates
#             reciveve mabox coordinates and que sheet
#             compare differences between user and mapbox coordinates
#             if n coordinates differ by x amount 
#                 run api again on an unsimplified version of that segment
#                 do untill no diff for that segment
            
#             if no major differences between user gpx and mapbox coords,
#                 add instructions to que sheet
    
#     present que sheet to user 



#TODO: shapely nearest_points to get start and end point
    '''
    # lon, lat
    Build list of shapely points of my mygpx.tracks[0].segments[0].points

    #this list is red points 
    shapelypoints = []s
    FOR tuple in mygpx.tracks[0].segment[0].points:
        shapelypoints.append(shapely.Point(tuple[0],tuple[1]))

    mltpt = MultiPoint(shapelypoints)

    # GREEN POINTS 
    simplified_start Pont(lon,lat) from routesegment[0]
    simplified_end Pont(lon,lat) from routesegment[-1]

    shapely.ops.nearest_point will find closest red point to the green point


    shapelypoints = [Point(lon,lat) for lon, lat in mygpx.tracks[0].segments[0].points ]
    
    shapely.ops.nearest_point on shapelypoints with start and end to get the start and end of the 
    segment that we are dealing with in the original route 
    '''